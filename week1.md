# 토론 내용
### 부스트캠프 커뮤니티는 어떤 커뮤니티가 되어야 할까? 커뮤니티라는 건 무엇일까?
* 커뮤니티 온라인에서 만나는건 커뮤니티가 맞는가에 대한 의문이 제기 되었다.
* 사람끼리 직접 만나서 대화하는 것이 더 많은 이야기가 나올 수 있고 icebreak를 할 수 있어 더 커뮤니티스럽고
* 반면, 온라인상에서는 약간의 거리감이나 어색함이 존재할 수 있다는 점에서, 진정한 커뮤니티의 느낌을 받기 어려울 수도 있다는 고민이 있었다.

### 서로 AI를 어떻게 활용하고 사용을 했는가?
- 재영님) 문법적으로 부족하거나 그럴때는 ai를 사용하고 전체적인 코드 작성은 직접 하는게 맞다고 생각한다.
- 영대님) 개념적으로 궁금한거 있을 때 종류에 따라서 AI검색을 사용 하고, 구현 자체에는 도움을 받고 있으나 설계에서는 직접 한다.
- 민우님) 코드 작성 때는 거의 사용 하지 않으려고 한다. (너무 코드가 장황해지는 것 같음)
- 새결님) 구현에도 가능하면 지양 하고 설계에서는 사용 안하는 편이 좋을 것 같다 생각한다.

### AI에게 글을 작성해달라는거는 괜찮은가?
- 재영님) 내 감정이나 의도가 잘 스며들게 좋은 표현으로 작성해달라는 식은 괜찮으나 아예 어떤일에 대해 만들어달라 라는 방식은 좋지 않다고 생각한다.
- 새결님) 전체적인 글은 직접 작성하고, 표현이 어색한 부분등에서 가독성 좋게 바꿔 달라 이런 정도로 사용하는건 괜찮다고 생각한다.
- 민우님) 사용을 최근에 사람들이 많이 하는것 같은데 자신의 의도가 포함되지 않는 것이 별로 좋지 않다고 생각한다. 
- 영대님) 도움을 받는것은 괜찮지만 완전히 대신 써달라는건 안된다. 자신의 의미가 잘 전달이 안될 수도 있기 때문이다.

### 챌린지를 하며 놓치고 있는 것과 과도하게 집중하고 있는 것은 무엇일까? 어떻게 보완할 수 있을까?
전체적으로 비슷한 고민을 하고 있었다.
학습과 구현에 대해서 밸런스를 잘 잡지 못했고 실생활과 부스트캠프 활동간의 활동 밸런스를 잘 잡지 못했고 그로 인해 무너지는 라이프 밸런스에 대해서 이야기 했다.

### 부스트캠프에서 1주차를 보내면서 아쉬웠던 게 있었나? 시도해 보고 싶었지만 망설였던 게 있나?
js나 kotlin 스럽게 코드를 작성하고 싶었는데, 여러 학습과 구현에 정해진 시간에 맞추려고 하다 보니 스타일 지키는게 쉽지 않은 공통된 힘듬을 가지고 있었다.

### 피어 피드백을 어떻게 진행 했었고, 어땠는가?
* 서로 코드에 대한 설명을 나누고, 어려웠던 점이나 인사이트를 공유함
* 길잡이 자료의 지도를 함께 확인하며 구체적인 방향성에 대해 이야기 나눈 것이 유익했다는 피드백이 있었음.

### 결론👁️‍🗨️
- AI는 우리 학습과 작업에 있어 강력한 보조 도구지만, 주체는 항상 `나`여야 합니다.
- AI에게 지나치게 의존하기보다는, 내 생각과 의도를 분명히 한 후 도움을 주는 도구로 활용하는 것이라고 생각합니다.
- AI는 글쓰기에서 표현을 다듬고, 코드 작성에서 반복 작업을 줄이며, 개념 정리에 도움을 줄 수 있지만, 핵심적인 아이디어나 의사 결정, 감정 표현은 스스로 주도해야 합니다.
- AI는 나의 성장과 표현을 도와주는 `서포터`로 활용해야 하며, `대신하는 존재`가 되어서는 안 됩니다.
- AI를 도구로써 생산성있게 사용하면서, 그 중심에는 항상 나의 판단과 경험이 있도록 하는 것이 중요합니다.

# 나눈 이야기
#### 다음과 같은 기능을 만들면 어떨지에 대한 이야기를 나누어 보았다.
- 커뮤니티를 활성화 하는 GPT 기능으로  예)중복 질문에 대해서 질문이 쌓여있는거 퀘스트로 제안
- 비정형화 되어있는 ai 전처리 (사람이 볼 수 있게, 코드가 읽기 편하게 등) 프롬프트 퀘스트로 하나 제안
- 회고 작성 자기가 먼저 작성해보고 ai가 작성하게 시켜서 자신의 부족했던 점을 보완 할 수 있게 하는 것
- 체크포인트에 대해서 만들어주는것이 아닌 내가 짠 체크 포인트에서 보완할 점을 알려주는 프롬프트
- 모든 사람들의 체크포인트를 수집 해서 비교 분석을 하고 통계를 내는 명령 (학습과 성장을 시각적으로 확인 할 수 있게 하기) (+ commit 이나 학습 정리 등도 가능)

# 만든 퀘스트 
## 1. 커뮤니티 키워드 요약하기
### 배경 
- 커뮤니티에서 활발하게 오가는 메세지들에 대해 모두 인지하기 어렵다.
### 목적 
- 자주 언급되는 키워드를 시각화하여 인기 있는 주제를 빠르게 파악한다.
### 달성 기준  
- 슬랙 메세지 데이터를 수집 및 전처리
- 키워드 통계를 통해 인기 키워드 순위 또는 워드 클라우드 형태로 제공

## 2. AI를 활용한 비정형화 데이터 처리하기
### 의도
- 우리가 수행하는 대부분의 과제에는 데이터를 받아 파싱하고 처리하는 과정이 포함되어 있습니다.
- 이 과정에서 중요한 것은, 컴퓨터가 이해할 수 있는 형태로 데이터를 정제하는 것뿐만 아니라, 사람도 쉽게 확인하고 이해할 수 있게 만드는 것입니다.
- AI를 활용해 이러한 전처리 작업을 실습해보고, 비정형 데이터를 다루는 감각을 키워보는 것이 이번 퀘스트의 목표입니다.

### 목적
- 실제 세상에서 주어지는 데이터는 대부분 비정형입니다. (예: 이미지, 영상, 자유형식 문서, 회의록, 로그 등)
- 우리는 이처럼 정제되지 않은 데이터 속에서 의미 있는 정보를 AI의 도움을 받아 추출해보고자 합니다.

### 달성 조건
- 하나 이상의 비정형 데이터를 선택해 분석합니다. (예: 이미지, 자유 텍스트, 스크린샷, 문서 등 자유롭게 선택 가능)
- AI를 활용해 아래 조건을 만족해보세요.
- 의미 있는 키워드 또는 정보를 추출하기
- 해당 키워드나 항목에 대한 수치적 또는 요약적 분석 결과 얻기
- 사용한 프롬프트와 AI 응답 결과를 함께 기록하기

## 3. AI에게 회고 피드백 받아보기
### 배경 
- AI를 내 성장에 도움이 되는 서포터로 사용해보자
### 목적 
- 내가 쓴 회고를 AI에게 피드백 받아 발전시킬 부분을 찾아보고 정리해본다.
### 달성기준
- 한주의 회고를 AI에게 보내 피드백을 받는다
- 피드백 받은 부분을 정리하거나 수행해본다

## 4. 체크포인트를 통한 통계와 자신의 체크포인트 피드백 받기
### 배경 
- 설정한 체크포인트의 적절성과 효과성을 스스로 판단하기 어렵다.
### 목적 
- 구성원들의 체크포인트 데이터를 통계화하여 활용한다.
### 달성 기준
- .md 형태의 체크 포인트 정보를 수집한다.
- 유사한 체크 포인트를 분류하여 통계화한다


# 퀘스트 수행 과정

## 퀘스트 선정
- **J143**: `3. AI에게 회고 피드백 받아보기`
- **J223**: `4. 체크포인트를 통한 통계와 자신의 체크포인트 피드백 받기`
- **J227**: `3. AI에게 회고 피드백 받아보기`
- **K002**: `3. AI에게 회고 피드백 받아보기`
- **J158**: `4. 체크포인트를 통한 통계와 자신의 체크포인트 피드백 받기`

## 퀘스트 수행
<details>
<summary>J143</summary>

</details>

<details>
<summary>J223</summary>

</details>

<details>
<summary>J227</summary>

- 저는 1주차 활동을 진행하고 작성한 회고를 AI에게 주어 피드백을 받아보았습니다.
- 처음에는 그냥 "내가 작성한 회고에 대해서 피드백을 줘" 라고 물어봤더니, 약간 부족한 듯한 피드백을 받았습니다.
- 글의 표현력에 대한 피드백도 받고 싶었지만, 이 외에도 글의 내용, 추가하면 좋을 부분에 대한 의견도 받으면 좋을 것 같다는 생각이 들었습니다.
- AI 프롬프트에 대해서 더 알아보았더니, AI가 맡을 역할, 질문의 맥락, 데이터의 입력 내용과 원하는 출력을 명시해주는 것이 좋다는 것을 배웠습니다.
- AI에게 "글을 읽고 적절한 피드백을 해줄 수 있는 글쓰기 선생님"의 역할을 주고, 잘했던 점, 개선이 필요한 점 그리고 추가하면 좋을 점을 출력해달라고 요청하였습니다.
- 그 결과 다음과 같은 피드백을 얻을 수 있었습니다:

```
  - 내 의견을 조금 더 직접적이고 자연스럽게 표현하기
  - 자기 성찰을 살짝 더 구체화해보기, 느낀 점을 더 자세히 표현하기
  - 오타 수정하기 (헉... ㅠㅠ)
  - 다음에는 어떻게 활동을 진행할 것인지 구체적인 예시를 들어서 실현해보기
```

- 이번 릴레이 프로젝트를 통해 배운 점: 프롬프트를 약간 더 조심스럽게, 자세히 작성해주면 AI를 더 효과적으로 사용할 수 있다.
- 다음주에 실행해 볼 계획: AI를 통해서 학습해야 할 내용을 자세히 정리해보고, 회고 도중에도 다음에 실행할 예시를 하나 정도 들어보기


</details>

<details>
<summary>K002</summary>
7일차 미션에 아래와 같이 간단한 회고를 작성했습니다.  

오늘 미션을 하며 야크털을 털실 뭉치정도 깎은 것 같습니다. 학습할 내용을 잘 구분하고 상세히 정하는 것이
필요하다는 것도 느꼈습니다. 미션을 하며 잠을 늦게 자서 컨디션 유지가 쉽지 않은 것 같습니다. 오늘도 일찍 자야겠다고 생각했는데
벌써 새벽 3시가 넘었네요. 내일은 컨디션을 위해 반드시 적어도 새벽 2시에 자야겠습니다.

그리고 ChatGPT에게 회고에대한 피드백을 달라고 했습니다. 받은 피드백은 아래와 같습니다.

✅ 잘한 점
자기 성찰이 구체적이에요

"야크털을 털실 뭉치 정도 깎은 것 같습니다."
이 비유는 재밌고 직관적이에요. 복잡하고 본질과 거리가 있는 작업에 시간과 에너지를 들였다는 걸 유머 있게 표현해서 회고에 생동감이 있어요.

문제 인식과 학습 방향 설정이 좋습니다

"학습할 내용을 잘 구분하고 상세히 정하는 것이 필요하다는 것도 느꼈습니다."
무엇이 부족했는지 파악했고, 다음 미션에서 어떻게 개선할지 방향을 제시했어요. 이런 메타인지 능력은 성장에 정말 중요한 자질이에요.

자기 관리에 대한 고민이 드러나요

"오늘도 일찍 자야겠다고 생각했는데 벌써 새벽 3시가 넘었네요."
스스로 컨디션 문제를 인식하고, 개선하려는 의지가 보여서 좋아요. 단순한 다짐이 아니라 시간까지 명시적으로 정했다는 점에서 실행력도 기대돼요.

🔍 개선하면 더 좋을 점
구체적인 원인 분석이 추가되면 좋아요
예: 왜 학습할 내용을 잘 구분하지 못했는가? 어떤 지점에서 흐트러졌는가?
→ 이런 질문을 던지면 더 깊이 있는 회고가 되고, 반복을 줄일 수 있어요.

행동 계획이 조금 더 명확하면 좋습니다

"적어도 새벽 2시에 자야겠습니다."
좋지만, 어떻게 2시에 자게 만들 건지 간단한 전략을 덧붙이면 실천 가능성이 훨씬 높아요.
예: "1시 30분에는 작업을 멈추고 정리한다" 같은 행동 기준이 있으면 좋겠어요.

🌟 총평
성찰 → 문제 인식 → 다짐의 흐름이 자연스럽고 진정성이 있어요. 단순한 일기 느낌이 아니라, 다음에 더 잘하기 위한 회고로 기능하고 있다는 점에서 이미 굉장히 잘 쓰고 계신 겁니다. 다음 회고에서는 “어떤 선택이 야크털이었는지”를 구체화하고, 수면 전략도 함께 실험해보면 더 멋질 거예요.

위 피드백을 바탕으로 아래와 같이 수정했습니다.

오늘 미션을 하며 야크털을 털실 뭉치정도 깎은 것 같습니다. 파일관리의 목적이나 최소 요구조건은 굳이 학습하지 않아도 될 것 같습니다.
(전공책의 파일관리 부분을 읽으며 야크털을 더 깎으려다 멈춘 것이 다행이려나요.) 학습할 내용을 잘 구분하고 상세히 정하는 것이
필요하다는 것도 느꼈습니다. 미션을 하며 잠을 늦게 자서 컨디션 유지가 쉽지 않은 것 같습니다. 늦게 잠->졸림->낮잠->미션할 시간 부족->늦게 잠
이 패턴이 반복되네요. 오늘도 일찍 자야겠다고 생각했는데
벌써 새벽 3시가 넘었네요. 내일은 컨디션을 위해 적어도 새벽 2시에 자기 위해 1시 30분에 하던 것까지만 정리하고 자야겠습니다.
  
</details>

<details>
<summary>J158</summary>
  
# Day06
이번 미션에서 동료분들의 체크리스트를 보면서 나의 체크리스트가 많이 부족하다고 느끼게 되었습니다. 실제로 AI를 활용한 통계로도 미흡하거나 작성하지 못한 부분을 확인할 수 있었습니다.
다음 미션부터는 해야할일을 구체적인 항목으로 나눠서 작성하여 이번 미션에서 미흡한 부분을 보완하고자 합니다.

## ✅ 비교 통계표

| 항목 구분       | 주요 세부 항목                        | 팀 동료 리스트 상세도             | 나의 리스트 상세도       | 설명                     |
| ----------- | ------------------------------- | ------------------------ | ---------------- | ---------------------- |
| 사전 학습    | 객체지향 개념, 클래스/객체, 프로토타입, SOLID   | 매우 자세함 (정의 + 개념 + 구조 학습) | 충분히 포함됨 (요약 중심)  | 동료는 SOLID까지 포함하여 더 구조적 |
| 게임 룰 정리  | 캐릭터 규칙, 배치, 공격, 종료조건            | ✅ 자세히 정리                 | ✅ 간단 정리          | 둘 다 충실하게 반영함           |
| 구조 설계    | 디렉토리 분리, 모듈 분리, 역할 할당           | ✅ 디렉토리/모듈 역할까지 명확히       | ❌ 디렉토리/모듈 구조 미기술 | 동료가 더 구체적인 설계 기반 있음    |
| 클래스 설계  | Board, Character, GameManager 등 | ✅ 다이어그램, 역할 정리 포함        | ✅ 클래스 항목 포함      | 동료는 시각화 설계까지 진행함       |
| 캐릭터별 분석  | 각 캐릭터 능력/제약                     | ✅ 상세 규칙, 스톤, 능력 다수 정리    | ✅ 기본 규칙 정리       | 동료가 이동/공격 알고리즘까지 고려함   |
| 테스트 설계   | 단위 테스트, 예외 테스트                  | ✅ 테스트 케이스 항목 포함          | ❌ 미포함            | 동료가 테스트에 대한 계획이 명확함    |
| 입출력 처리   | Input/Renderer 모듈 설계            | ✅ I/O 책임 분리 기술           | ✅ Main 객체로 처리 기술 | 둘 다 방향성은 있지만 동료가 더 명확  |
| 게임 루프    | 루프 흐름 / 예외처리 / 종료조건             | ✅ 컴퓨터 턴, 종료조건 설계 포함      | ❌ 컴퓨터 턴/종료조건 미포함 | 동료가 턴 흐름을 더 깊게 설계함     |
| 예외 상황 분석 | 형식 오류, 캐릭터 없음 등                 | ✅ 입력 에러, 팀 충돌 등 포함       | ❌ 미포함            | 예외 처리 플랜이 부족           |
| 문서화      | README, 설계도, 학습정리 등             | ✅ 체크리스트, 설계 이미지 포함       | ❌ 별도 문서 없음       | 동료가 문서화를 더 철저히 함       |

## 📊 통계 요약

| 항목        | 팀 동료 수준 | 나의 수준      |
| --------- | ------- | ---------- |
| 사전 학습 깊이  | 매우 우수   | 우수         |
| 요구사항 분석   | 우수      | 우수         |
| 설계 상세도    | 매우 우수   | 보통         |
| 클래스 구조화   | 우수      | 우수         |
| 캐릭터 구현 계획 | 매우 우수   | 보통         |
| 테스트 설계    | 있음      | 없음         |
| I/O 구조 분리 | 있음      | 있음 (덜 구체적) |
| 게임 흐름 설계  | 있음      | 미흡         |
| 예외 시나리오   | 있음      | 없음         |
| 문서화       | 있음      | 없음         |

## 🏆 가장 이상적인 투두리스트 예시 (최종 통합 버전)

```md
# ✅ 마블 보드게임 최적의 투두리스트

## 1. 객체지향 개념 학습
- [x] 클래스, 인스턴스, 객체 차이 정리
- [x] 캡슐화, 상속, 다형성 개념 정리
- [x] JS에서 클래스 vs 프로토타입 차이 학습
- [x] SOLID 원칙 요약 (SRP, LSP 등)

## 2. 게임 규칙 분석
- [x] 캐릭터 이동/공격/HP/스톤 규칙 정리
- [x] 타노스 조건 및 스톤 훔치기 로직 정리
- [x] 각 캐릭터 이동 제약 정리
- [x] 게임 종료 조건 명시

## 3. 설계
- [x] 클래스 다이어그램 (Board, Character, GameManager 등)
- [x] 디렉토리 구조 설계 (src/characters, src/game, src/ui 등)
- [x] Position 타입 및 Board 격자 구조 설계
- [x] 캐릭터 상속 구조 설계 및 역할 정의

## 4. 구현
- [x] Character 부모 클래스 구현 (HP, attack, setPosition, etc)
- [x] 캐릭터별 클래스 구현 (Thanos, BW, HK, etc)
- [x] Board 구현 (배치, 공격, 이동, 확인 함수)
- [x] GameManager 구현 (setup, playTurn, 턴 전환)
- [x] Main 입력 루프 구현 (readline 처리)

## 5. 예외 처리 & 테스트
- [x] 위치 중복 / 턴 오류 / 입력 오류 처리
- [x] 공격 시 없는 대상 처리, 같은 팀 공격 방지
- [x] 테스트 시나리오 (생성, 이동, 공격, 제거, 스톤 탈취 등)

## 6. 보조 기능
- [x] 전체 HP 출력 ('?' 입력)
- [x] 턴 순환 및 컴퓨터 자동 입력
- [x] 게임 종료 조건 처리 및 출력

## 7. 문서화 & 리팩터링
- [x] README.md 작성 (기능/설계 요약)
- [x] 학습정리.md 작성 (OOP 개념 정리)
- [x] 기능별 커밋 관리 (gist 활용)

```
---

# Day07
오늘 미션에서는 Day06보다 체크리스트를 더욱 구체적으로 작성하려고 노력했습니다. 동료들과의 비교 통계를 통해서도 어제보다 세부적인 항목들을 기록했다는 점을 확인할 수 있었습니다.
또한, 한 동료 분께서 이번 미션에서 diagrams.net을 활용해 사전 설계를 다이어그램으로 정리하신 것을 보고, 설계를 시각화하는 것의 중요성을 다시금 깨달았습니다. 저 역시 이번 미션에서는 다이어그램을 통한 설계를 미처 고려하지 못했는데, 시각화된 설계는 나 자신에게도 더 정밀한 구조를 떠올리게 하고, 다른 사람에게도 내용을 쉽게 전달할 수 있다는 점에서 매우 유용하다는 점을 배웠습니다.
이에 따라 다음 미션부터는 체크리스트에서도 부족하다고 지적된 설계 시각화 부분을 보완하여, 다이어그램 중심의 설계를 적극 반영하고자 합니다.

## ✅ 비교 통계표

| 항목 구분       | 주요 세부 항목                                       | 동료 리스트 상세도                 | 나의 리스트 상세도               | 설명                                                             |
| -------------- | ---------------------------------------------------- | --------------------------------- | ------------------------------- | ---------------------------------------------------------------- |
| 사전 학습    | 파일 시스템, 디렉토리/파일 구조, FAT, 시스템콜 이해         | ✅ 매우 자세함 (하위 구조까지 포함)  | ✅ 포함됨 (요점 중심 요약)         | 동료는 커널·FAT·inode까지 포함해 더 깊이 있게 정리함              |
| 요구사항 분석 | 명령어 정리, 기능 명세, 용량 및 포맷 제한 등 분석            | ✅ 세부 명령/예외 조건까지 정리      | ✅ 명령어 중심 정리                | 둘 다 명령 위주 정리, 동료는 경계 케이스까지 분석함               |
| 설계         | 기능 분할 설계, CLI 흐름, 모듈 역할 구분                   | ✅ 기능 흐름도 및 구조 설계 이미지 포함 | ⚠️ 항목은 있지만 시각화/모듈 설계 없음 | 동료가 흐름도/역할 분리까지 상세 설계함                           |
|  기능 구현    | init, makedir, create, read, list, export/import 구현 | ✅ 전체 구현                        | ✅ 전체 구현                      | 구현 자체는 동등함, 코드 구조 설계는 동료가 더 명확함              |
| 영속성       | myfs.dat 저장/복원, revive 함수, Map 변환 처리            | ✅ 파일 구조 분리(myfs.dat/dir/info) | ✅ 단일 파일(myfs.dat) 사용        | 동료는 파일 종류 분리 설계, 나는 하나의 JSON으로 저장 처리        |
| 단위 테스트  | Jest 테스트 구성, 정상/예외 케이스 테스트 작성             | ✅ 각 기능 별 케이스, 커버리지 확인   | ✅ 대부분 구현, 일부 미흡            | 테스트 항목은 구현, 예외 처리나 삭제 기능 테스트는 미흡함         |
| 테스트 설계  | 테스트 순서 계획, 함수 우선순위, 커버리지 전략              | ✅ 계획 수립 및 커버리지 수치 목표     | ⚠️ 일부 항목만 있음                | 테스트 계획은 동료가 더 명확히 문서화함                            |
| 입력 처리    | 명령어 파싱, 인자 개수 체크, 에러 처리 로직                 | ✅ 상세 예외 처리                    | ✅ 기본적인 토큰 분리               | 동료는 인자 수 오류/포맷 오류에 더 철저한 메시지 처리              |
| 출력 처리    | 출력 메시지 형식 통일, 성공/오류 응답                     | ✅ 정형화된 출력 설계                | ✅ 명령어에 따른 출력 작성          | 둘 다 명령어별 응답을 잘 구성했음                                |
| 문서화       | README, 학습정리, 클래스/기능 구조도                     | ✅ 설계 이미지, 체크리스트 포함        | ⚠️ 단순 README.md만 작성성               | 동료는 구조 다이어그램까지 포함해 더 풍부한 문서화                 |


## ✅ 최종 체크리스트
```
### \[사전 학습]
- [x] 파일 시스템 구조 (inode, 디렉토리, 블록)
- [x] 파일 I/O와 시스템콜 이해
- [x] FAT 구조와 동작 방식
- [x] 가상 메모리 & 인메모리 구현 의미

### \[요구사항 분석]

- [x] CLI 명령어 명세 정리
- [x] import/export 명령어 흐름 파악
- [x] 인메모리 vs 영속성 요구사항 비교

### \[설계]

- [x] CLI ↔ 파서 ↔ FS 흐름 설계
- [x] 파일/디렉토리 자료구조 정의
- [x] save/load 시 JSON 포맷 설계
- [x] 오류 처리 설계 (없는 경로, 용량 초과 등)

### \[구현]

- [x] init, makedir, create, read, list
- [x] saveState, loadState, reviveDirectory
- [x] import, export (호스트 파일 연동)

### \[단위 테스트]

- [x] Jest 설치 및 실행
- [x] 정상 케이스 테스트
- [x] 에러/예외 상황 테스트
- [x] 영속성 테스트 (파일 저장/불러오기)
- [x] 커버리지 측정 및 CI 연동 (선택)
```

## 🔍 **종합 분석**

* 구현 파트는 핵심 기능(`init`, `makedir`, `create`, `read`, `list`, `영속성`) 중심으로 잘 진행되어 있으며,
* 단위 테스트도 영속성까지 테스트한 점이 우수합니다.
* 다만, `사전 학습`과 `요구사항/설계 분석`은 README.md 등에 명확하게 기술되어야 미션의 완성도로 인정받기 좋습니다.
* 특히 `import/export`, 시스템콜/파일 포맷 등은 이후 기능 확장성 측면에서도 중요합니다.
  
</details>
