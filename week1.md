# 토론 내용

### 부스트캠프 커뮤니티는 어떤 커뮤니티가 되어야 할까? 커뮤니티라는 건 무엇일까?

- 커뮤니티 온라인에서 만나는건 커뮤니티가 맞는가에 대한 의문이 제기 되었다.
- 사람끼리 직접 만나서 대화하는 것이 더 많은 이야기가 나올 수 있고 icebreak를 할 수 있어 더 커뮤니티스럽고
- 반면, 온라인상에서는 약간의 거리감이나 어색함이 존재할 수 있다는 점에서, 진정한 커뮤니티의 느낌을 받기 어려울 수도 있다는 고민이 있었다.

### 서로 AI를 어떻게 활용하고 사용을 했는가?

- 재영님) 문법적으로 부족하거나 그럴때는 ai를 사용하고 전체적인 코드 작성은 직접 하는게 맞다고 생각한다.
- 영대님) 개념적으로 궁금한거 있을 때 종류에 따라서 AI검색을 사용 하고, 구현 자체에는 도움을 받고 있으나 설계에서는 직접 한다.
- 민우님) 코드 작성 때는 거의 사용 하지 않으려고 한다. (너무 코드가 장황해지는 것 같음)
- 새결님) 구현에도 가능하면 지양 하고 설계에서는 사용 안하는 편이 좋을 것 같다 생각한다.

### AI에게 글을 작성해달라는거는 괜찮은가?

- 재영님) 내 감정이나 의도가 잘 스며들게 좋은 표현으로 작성해달라는 식은 괜찮으나 아예 어떤일에 대해 만들어달라 라는 방식은 좋지 않다고 생각한다.
- 새결님) 전체적인 글은 직접 작성하고, 표현이 어색한 부분등에서 가독성 좋게 바꿔 달라 이런 정도로 사용하는건 괜찮다고 생각한다.
- 민우님) 사용을 최근에 사람들이 많이 하는것 같은데 자신의 의도가 포함되지 않는 것이 별로 좋지 않다고 생각한다.
- 영대님) 도움을 받는것은 괜찮지만 완전히 대신 써달라는건 안된다. 자신의 의미가 잘 전달이 안될 수도 있기 때문이다.

### 챌린지를 하며 놓치고 있는 것과 과도하게 집중하고 있는 것은 무엇일까? 어떻게 보완할 수 있을까?

전체적으로 비슷한 고민을 하고 있었다.
학습과 구현에 대해서 밸런스를 잘 잡지 못했고 실생활과 부스트캠프 활동간의 활동 밸런스를 잘 잡지 못했고 그로 인해 무너지는 라이프 밸런스에 대해서 이야기 했다.

### 부스트캠프에서 1주차를 보내면서 아쉬웠던 게 있었나? 시도해 보고 싶었지만 망설였던 게 있나?

js나 kotlin 스럽게 코드를 작성하고 싶었는데, 여러 학습과 구현에 정해진 시간에 맞추려고 하다 보니 스타일 지키는게 쉽지 않은 공통된 힘듬을 가지고 있었다.

### 피어 피드백을 어떻게 진행 했었고, 어땠는가?

- 서로 코드에 대한 설명을 나누고, 어려웠던 점이나 인사이트를 공유함
- 길잡이 자료의 지도를 함께 확인하며 구체적인 방향성에 대해 이야기 나눈 것이 유익했다는 피드백이 있었음.

### 결론👁️‍🗨️

- AI는 우리 학습과 작업에 있어 강력한 보조 도구지만, 주체는 항상 `나`여야 합니다.
- AI에게 지나치게 의존하기보다는, 내 생각과 의도를 분명히 한 후 도움을 주는 도구로 활용하는 것이라고 생각합니다.
- AI는 글쓰기에서 표현을 다듬고, 코드 작성에서 반복 작업을 줄이며, 개념 정리에 도움을 줄 수 있지만, 핵심적인 아이디어나 의사 결정, 감정 표현은 스스로 주도해야 합니다.
- AI는 나의 성장과 표현을 도와주는 `서포터`로 활용해야 하며, `대신하는 존재`가 되어서는 안 됩니다.
- AI를 도구로써 생산성있게 사용하면서, 그 중심에는 항상 나의 판단과 경험이 있도록 하는 것이 중요합니다.

# 나눈 이야기

#### 다음과 같은 기능을 만들면 어떨지에 대한 이야기를 나누어 보았다.

- 커뮤니티를 활성화 하는 GPT 기능으로 예)중복 질문에 대해서 질문이 쌓여있는거 퀘스트로 제안
- 비정형화 되어있는 ai 전처리 (사람이 볼 수 있게, 코드가 읽기 편하게 등) 프롬프트 퀘스트로 하나 제안
- 회고 작성 자기가 먼저 작성해보고 ai가 작성하게 시켜서 자신의 부족했던 점을 보완 할 수 있게 하는 것
- 체크포인트에 대해서 만들어주는것이 아닌 내가 짠 체크 포인트에서 보완할 점을 알려주는 프롬프트
- 모든 사람들의 체크포인트를 수집 해서 비교 분석을 하고 통계를 내는 명령 (학습과 성장을 시각적으로 확인 할 수 있게 하기) (+ commit 이나 학습 정리 등도 가능)

# 만든 퀘스트

## 1. 커뮤니티 키워드 요약하기

### 배경

- 커뮤니티에서 활발하게 오가는 메세지들에 대해 모두 인지하기 어렵다.

### 목적

- 자주 언급되는 키워드를 시각화하여 인기 있는 주제를 빠르게 파악한다.

### 달성 기준

- 슬랙 메세지 데이터를 수집 및 전처리
- 키워드 통계를 통해 인기 키워드 순위 또는 워드 클라우드 형태로 제공

## 2. AI를 활용한 비정형화 데이터 처리하기

### 의도

- 우리가 수행하는 대부분의 과제에는 데이터를 받아 파싱하고 처리하는 과정이 포함되어 있습니다.
- 이 과정에서 중요한 것은, 컴퓨터가 이해할 수 있는 형태로 데이터를 정제하는 것뿐만 아니라, 사람도 쉽게 확인하고 이해할 수 있게 만드는 것입니다.
- AI를 활용해 이러한 전처리 작업을 실습해보고, 비정형 데이터를 다루는 감각을 키워보는 것이 이번 퀘스트의 목표입니다.

### 목적

- 실제 세상에서 주어지는 데이터는 대부분 비정형입니다. (예: 이미지, 영상, 자유형식 문서, 회의록, 로그 등)
- 우리는 이처럼 정제되지 않은 데이터 속에서 의미 있는 정보를 AI의 도움을 받아 추출해보고자 합니다.

### 달성 조건

- 하나 이상의 비정형 데이터를 선택해 분석합니다. (예: 이미지, 자유 텍스트, 스크린샷, 문서 등 자유롭게 선택 가능)
- AI를 활용해 아래 조건을 만족해보세요.
- 의미 있는 키워드 또는 정보를 추출하기
- 해당 키워드나 항목에 대한 수치적 또는 요약적 분석 결과 얻기
- 사용한 프롬프트와 AI 응답 결과를 함께 기록하기

## 3. AI에게 회고 피드백 받아보기

### 배경

- AI를 내 성장에 도움이 되는 서포터로 사용해보자

### 목적

- 내가 쓴 회고를 AI에게 피드백 받아 발전시킬 부분을 찾아보고 정리해본다.

### 달성기준

- 한주의 회고를 AI에게 보내 피드백을 받는다
- 피드백 받은 부분을 정리하거나 수행해본다

## 4. 체크포인트를 통한 통계와 자신의 체크포인트 피드백 받기

### 배경

- 설정한 체크포인트의 적절성과 효과성을 스스로 판단하기 어렵다.

### 목적

- 구성원들의 체크포인트 데이터를 통계화하여 활용한다.

### 달성 기준

- .md 형태의 체크 포인트 정보를 수집한다.
- 유사한 체크 포인트를 분류하여 통계화한다

# 퀘스트 수행 과정

## 퀘스트 선정

- **J143**: `3. AI에게 회고 피드백 받아보기`
- **J223**: `4. 체크포인트를 통한 통계와 자신의 체크포인트 피드백 받기`
- **J227**: `3. AI에게 회고 피드백 받아보기`
- **K002**: `3. AI에게 회고 피드백 받아보기`
- **J158**: `4. 체크포인트를 통한 통계와 자신의 체크포인트 피드백 받기`

## 퀘스트 수행

<details>
<summary>J143</summary>

지난 주 회고에 대해 AI 한테 피드백을 부탁하여 아래의 답변을 얻었습니다.

프롬프트로는 부스트캠프 전반에 대한 설명과 저의 회고 전문을 사용했습니다.

### 회고 피드백

✅ 강점 요약

**깊이 있는 자기 성찰**: 문제 해결 과정에서 느낀 어려움과 원인을 명확히 파악함. \
**AI 활용에 대한 비판적 사고**: 단순 사용을 넘어서 학습 효과를 고민함. \
**동료 피드백을 실제 행동으로 연결**: 체크포인트 분리, 리드미 개선 등 실천으로 이어짐.

🔧 개선 제안

**설계 단계 연습 강화**: 구현 전 흐름도를 간단히 스케치해보는 습관을 추천. \
**검색 전략 명확화**: 키워드 중심의 리서치 계획 + AI는 정보 구조화 도구로 활용. \
**기록 습관 체계화**: 세 줄 요약을 발전시켜, 핵심 정리 문서 / Q&A 노트 형태로 확장.

🚀 다음주 실천 전략

체크포인트 기반 키워드 도출 → AI와 함께 리서치. \
구현 전 흐름도나 메모 작성 → 설계 감각 키우기. \
간단한 테스트 케이스 작성 후 AI로 확장 실험. \
리드미와 회고 정리를 타인 중심으로 계속 개선.

### 결과

이번 주에는 확실히 AI 를 어떻게 하면 더 잘 활용할 수 있을지 많은 고민을 하고 실천에 옮겼습니다.
AI 를 사용한 학습은 처음에 리서치 키워드를 도출하고 공부하면서 이해가 되지 않는 부분을 물어보는 용도로 많이 활용했습니다.
또한 테스트 케이스를 작성하는 데 있어 AI 의 도움을 많이 받았습니다.
그리고 학습 정리를 함에 있어 정리가 잘 안 되는 부분이 있으면 AI 를 사용해서 간결하게 만들었습니다.

</details>

<details>
<summary>J223</summary>

- 2주차 수요일 미션인 함수형프로그래밍의 같은 그룹의 캠퍼분들의 채크포인트와 비교해서 AI에서 물어보았습니다.

네, 보내주신 본인의 체크포인트와 팀원들의 체크포인트를 분석하고 비교하여 피드백을 드릴게요.

전반적으로 함수형 프로그래밍의 핵심 개념을 학습하고, 이를 바탕으로 자료구조와 도서 관리 프로그램을 구현하려는 목표가 명확하게 드러납니다.

### 체크포인트 통계 비교

먼저, 본인과 팀원들의 체크포인트를 주요 항목별로 나누어 비교해 보았습니다. 이를 통해 어떤 부분에 강점이 있고 어떤 부분을 보완할 수 있을지 파악할 수 있습니다.

| 구분 항목                  | 본인 | 팀원 1 | 팀원 2 |  팀원 3   |
| :------------------------- | :--: | :----: | :----: | :-------: |
| **학습 (Learning)**        | 상세 |  보통  |  보통  |   상세    |
| **설계 (Design)**          |  ❌  |   ❌   |   ❌   |    ✅     |
| **구현 (Implementation)**  | 상세 |  상세  |  보통  | 매우 상세 |
| **테스트 (Testing)**       | 보통 |   ❌   |  보통  | 매우 상세 |
| **요구사항/제약조건 명시** |  ❌  |   ✅   |   ✅   |    ❌     |
| **구조화 (Structure)**     | 보통 |  보통  |  보통  | 매우 우수 |

---

### '나만의 체크포인트' 피드백

#### 잘된 점 (Strengths) 👍

- **상세한 학습 계획**: 함수형 프로그래밍의 주요 개념(클로저, 불변성, 순수 함수 등)을 구체적으로 학습하려는 계획이 잘 세워져 있습니다.
- **구체적인 구현 목표**: 연결 리스트의 각 기능(`append`, `insert` 등)을 명확하게 나누어 구현 목표를 설정한 점이 좋습니다. 이는 실제 개발 진행 상황을 추적하는 데 효과적입니다.

#### 개선 제안 (Suggestions for Improvement) ✍️

1.  **'설계' 단계 추가**: **팀원 3**의 체크포인트처럼, 구현에 앞서 **'설계' 단계를 명시적으로 추가**하는 것을 추천합니다. 예를 들어, `연결리스트 구조 설계`, `해시맵 구조 설계`, `도서 정보 데이터 형식 정의` 같은 항목을 추가하면 구현 전에 전체적인 구조를 먼저 고민하게 되어 더 견고한 코드를 작성할 수 있습니다.

2.  **테스트 계획 구체화**: "작은 단위로 테스트 코드 작성하기"라는 목표를 더 구체화할 필요가 있습니다. **팀원 3**처럼 **"Jest로 단위 테스트 환경 구축"**, **"append() 기능 구현 및 테스트"** 와 같이 구현과 테스트를 하나의 쌍으로 묶어 관리하면, 각 기능이 완료될 때마다 누락 없이 테스트를 진행할 수 있습니다.

3.  **핵심 제약 조건 명시**: **팀원 1, 2**는 "불변성 유지", "반복문 대신 고차함수 사용" 등 프로젝트의 핵심 제약 조건을 체크포인트에 명시했습니다. 이런 **핵심 원칙을 상단에 명시**해두면 개발 과정 내내 목표를 잊지 않고 코드를 작성하는 데 도움이 됩니다.

4.  **작업 단위(Task) 세분화**: 연결 리스트에 비해 해시맵과 도서 관리 프로그램의 구현 항목이 다소 추상적입니다. 연결 리스트처럼 `put 구현하기`, `remove 구현하기`, `add(도서) 구현하기` 등으로 **작업 단위를 더 잘게 나누면** 진행 상황을 더 명확하게 파악하고 관리할 수 있습니다.

### 종합 의견

현재 체크포인트는 학습과 구현에 대한 목표를 잘 담고 있습니다. 여기에 **팀원들의 장점을 흡수**하여 **'설계' 단계를 추가**하고, **'테스트' 계획을 구체화**하며, **핵심 제약 조건을 명시**한다면 훨씬 더 명확하고 실용적인 개발 계획표가 될 것입니다. 특히 **팀원 3**의 '설계 → 구현 및 단위 테스트' 구조는 좋은 참고 자료가 될 수 있습니다.

</details>

<details>
<summary>J227</summary>

- 저는 1주차 활동을 진행하고 작성한 회고를 AI에게 주어 피드백을 받아보았습니다.
- 처음에는 그냥 "내가 작성한 회고에 대해서 피드백을 줘" 라고 물어봤더니, 약간 부족한 듯한 피드백을 받았습니다.
- 글의 표현력에 대한 피드백도 받고 싶었지만, 이 외에도 글의 내용, 추가하면 좋을 부분에 대한 의견도 받으면 좋을 것 같다는 생각이 들었습니다.
- AI 프롬프트에 대해서 더 알아보았더니, AI가 맡을 역할, 질문의 맥락, 데이터의 입력 내용과 원하는 출력을 명시해주는 것이 좋다는 것을 배웠습니다.
- AI에게 "글을 읽고 적절한 피드백을 해줄 수 있는 글쓰기 선생님"의 역할을 주고, 잘했던 점, 개선이 필요한 점 그리고 추가하면 좋을 점을 출력해달라고 요청하였습니다.
- 그 결과 다음과 같은 피드백을 얻을 수 있었습니다:

```
  - 내 의견을 조금 더 직접적이고 자연스럽게 표현하기
  - 자기 성찰을 살짝 더 구체화해보기, 느낀 점을 더 자세히 표현하기
  - 오타 수정하기 (헉... ㅠㅠ)
  - 다음에는 어떻게 활동을 진행할 것인지 구체적인 예시를 들어서 실현해보기
```

- 이번 릴레이 프로젝트를 통해 배운 점: 프롬프트를 약간 더 조심스럽게, 자세히 작성해주면 AI를 더 효과적으로 사용할 수 있다.
- 다음주에 실행해 볼 계획: AI를 통해서 학습해야 할 내용을 자세히 정리해보고, 회고 도중에도 다음에 실행할 예시를 하나 정도 들어보기

</details>

<details>
<summary>K002</summary>
7일차 미션에 아래와 같이 간단한 회고를 작성했습니다.

오늘 미션을 하며 야크털을 털실 뭉치정도 깎은 것 같습니다. 학습할 내용을 잘 구분하고 상세히 정하는 것이
필요하다는 것도 느꼈습니다. 미션을 하며 잠을 늦게 자서 컨디션 유지가 쉽지 않은 것 같습니다. 오늘도 일찍 자야겠다고 생각했는데
벌써 새벽 3시가 넘었네요. 내일은 컨디션을 위해 반드시 적어도 새벽 2시에 자야겠습니다.

그리고 ChatGPT에게 회고에대한 피드백을 달라고 했습니다. 받은 피드백은 아래와 같습니다.

✅ 잘한 점
자기 성찰이 구체적이에요

"야크털을 털실 뭉치 정도 깎은 것 같습니다."
이 비유는 재밌고 직관적이에요. 복잡하고 본질과 거리가 있는 작업에 시간과 에너지를 들였다는 걸 유머 있게 표현해서 회고에 생동감이 있어요.

문제 인식과 학습 방향 설정이 좋습니다

"학습할 내용을 잘 구분하고 상세히 정하는 것이 필요하다는 것도 느꼈습니다."
무엇이 부족했는지 파악했고, 다음 미션에서 어떻게 개선할지 방향을 제시했어요. 이런 메타인지 능력은 성장에 정말 중요한 자질이에요.

자기 관리에 대한 고민이 드러나요

"오늘도 일찍 자야겠다고 생각했는데 벌써 새벽 3시가 넘었네요."
스스로 컨디션 문제를 인식하고, 개선하려는 의지가 보여서 좋아요. 단순한 다짐이 아니라 시간까지 명시적으로 정했다는 점에서 실행력도 기대돼요.

🔍 개선하면 더 좋을 점
구체적인 원인 분석이 추가되면 좋아요
예: 왜 학습할 내용을 잘 구분하지 못했는가? 어떤 지점에서 흐트러졌는가?
→ 이런 질문을 던지면 더 깊이 있는 회고가 되고, 반복을 줄일 수 있어요.

행동 계획이 조금 더 명확하면 좋습니다

"적어도 새벽 2시에 자야겠습니다."
좋지만, 어떻게 2시에 자게 만들 건지 간단한 전략을 덧붙이면 실천 가능성이 훨씬 높아요.
예: "1시 30분에는 작업을 멈추고 정리한다" 같은 행동 기준이 있으면 좋겠어요.

🌟 총평
성찰 → 문제 인식 → 다짐의 흐름이 자연스럽고 진정성이 있어요. 단순한 일기 느낌이 아니라, 다음에 더 잘하기 위한 회고로 기능하고 있다는 점에서 이미 굉장히 잘 쓰고 계신 겁니다. 다음 회고에서는 “어떤 선택이 야크털이었는지”를 구체화하고, 수면 전략도 함께 실험해보면 더 멋질 거예요.

위 피드백을 바탕으로 아래와 같이 수정했습니다.

오늘 미션을 하며 야크털을 털실 뭉치정도 깎은 것 같습니다. 파일관리의 목적이나 최소 요구조건은 굳이 학습하지 않아도 될 것 같습니다.
(전공책의 파일관리 부분을 읽으며 야크털을 더 깎으려다 멈춘 것이 다행이려나요.) 학습할 내용을 잘 구분하고 상세히 정하는 것이
필요하다는 것도 느꼈습니다. 미션을 하며 잠을 늦게 자서 컨디션 유지가 쉽지 않은 것 같습니다. 늦게 잠->졸림->낮잠->미션할 시간 부족->늦게 잠
이 패턴이 반복되네요. 오늘도 일찍 자야겠다고 생각했는데
벌써 새벽 3시가 넘었네요. 내일은 컨디션을 위해 적어도 새벽 2시에 자기 위해 1시 30분에 하던 것까지만 정리하고 자야겠습니다.

</details>

<details>
<summary>J158</summary>
  
# Day06
이번 미션에서 동료분들의 체크리스트를 보면서 나의 체크리스트가 많이 부족하다고 느끼게 되었습니다. 실제로 AI를 활용한 통계로도 미흡하거나 작성하지 못한 부분을 확인할 수 있었습니다.
다음 미션부터는 해야할일을 구체적인 항목으로 나눠서 작성하여 이번 미션에서 미흡한 부분을 보완하고자 합니다.

## 📊 비교 통계표

| 항목 구분      | 주요 세부 항목                                | 팀 동료 리스트 상세도                 | 나의 리스트 상세도           | 설명                                 |
| -------------- | --------------------------------------------- | ------------------------------------- | ---------------------------- | ------------------------------------ |
| 사전 학습      | 객체지향 개념, 클래스/객체, 프로토타입, SOLID | 매우 자세함 (정의 + 개념 + 구조 학습) | 충분히 포함됨 (요약 중심)    | 동료는 SOLID까지 포함하여 더 구조적  |
| 게임 룰 정리   | 캐릭터 규칙, 배치, 공격, 종료조건             | ✅ 자세히 정리                        | ✅ 간단 정리                 | 둘 다 충실하게 반영함                |
| 구조 설계      | 디렉토리 분리, 모듈 분리, 역할 할당           | ✅ 디렉토리/모듈 역할까지 명확히      | ❌ 디렉토리/모듈 구조 미기술 | 동료가 더 구체적인 설계 기반 있음    |
| 클래스 설계    | Board, Character, GameManager 등              | ✅ 다이어그램, 역할 정리 포함         | ✅ 클래스 항목 포함          | 동료는 시각화 설계까지 진행함        |
| 캐릭터별 분석  | 각 캐릭터 능력/제약                           | ✅ 상세 규칙, 스톤, 능력 다수 정리    | ✅ 기본 규칙 정리            | 동료가 이동/공격 알고리즘까지 고려함 |
| 테스트 설계    | 단위 테스트, 예외 테스트                      | ✅ 테스트 케이스 항목 포함            | ❌ 미포함                    | 동료가 테스트에 대한 계획이 명확함   |
| 입출력 처리    | Input/Renderer 모듈 설계                      | ✅ I/O 책임 분리 기술                 | ✅ Main 객체로 처리 기술     | 둘 다 방향성은 있지만 동료가 더 명확 |
| 게임 루프      | 루프 흐름 / 예외처리 / 종료조건               | ✅ 컴퓨터 턴, 종료조건 설계 포함      | ❌ 컴퓨터 턴/종료조건 미포함 | 동료가 턴 흐름을 더 깊게 설계함      |
| 예외 상황 분석 | 형식 오류, 캐릭터 없음 등                     | ✅ 입력 에러, 팀 충돌 등 포함         | ❌ 미포함                    | 예외 처리 플랜이 부족                |
| 문서화         | README, 설계도, 학습정리 등                   | ✅ 체크리스트, 설계 이미지 포함       | ❌ 별도 문서 없음            | 동료가 문서화를 더 철저히 함         |

## 🔍 통계 요약

| 항목             | 팀 동료 수준 | 나의 수준        |
| ---------------- | ------------ | ---------------- |
| 사전 학습 깊이   | 매우 우수    | 우수             |
| 요구사항 분석    | 우수         | 우수             |
| 설계 상세도      | 매우 우수    | 보통             |
| 클래스 구조화    | 우수         | 우수             |
| 캐릭터 구현 계획 | 매우 우수    | 보통             |
| 테스트 설계      | 있음         | 없음             |
| I/O 구조 분리    | 있음         | 있음 (덜 구체적) |
| 게임 흐름 설계   | 있음         | 미흡             |
| 예외 시나리오    | 있음         | 없음             |
| 문서화           | 있음         | 없음             |

---

# Day07

오늘 미션에서는 Day06보다 체크리스트를 더욱 구체적으로 작성하려고 노력했습니다. 동료들과의 비교 통계를 통해서도 어제보다 세부적인 항목들을 기록했다는 점을 확인할 수 있었습니다.
또한, 한 동료 분께서 이번 미션에서 diagrams.net을 활용해 사전 설계를 다이어그램으로 정리하신 것을 보고, 설계를 시각화하는 것의 중요성을 다시금 깨달았습니다. 저 역시 이번 미션에서는 다이어그램을 통한 설계를 미처 고려하지 못했는데, 시각화된 설계는 나 자신에게도 더 정밀한 구조를 떠올리게 하고, 다른 사람에게도 내용을 쉽게 전달할 수 있다는 점에서 매우 유용하다는 점을 배웠습니다.
이에 따라 다음 미션부터는 체크리스트에서도 부족하다고 지적된 설계 시각화 부분을 보완하여, 다이어그램 중심의 설계를 적극 반영하고자 합니다.

## 📊 비교 통계표

| 항목 구분     | 주요 세부 항목                                        | 동료 리스트 상세도                      | 나의 리스트 상세도                     | 설명                                                       |
| ------------- | ----------------------------------------------------- | --------------------------------------- | -------------------------------------- | ---------------------------------------------------------- |
| 사전 학습     | 파일 시스템, 디렉토리/파일 구조, FAT, 시스템콜 이해   | ✅ 매우 자세함 (하위 구조까지 포함)     | ✅ 포함됨 (요점 중심 요약)             | 동료는 커널·FAT·inode까지 포함해 더 깊이 있게 정리함       |
| 요구사항 분석 | 명령어 정리, 기능 명세, 용량 및 포맷 제한 등 분석     | ✅ 세부 명령/예외 조건까지 정리         | ✅ 명령어 중심 정리                    | 둘 다 명령 위주 정리, 동료는 경계 케이스까지 분석함        |
| 설계          | 기능 분할 설계, CLI 흐름, 모듈 역할 구분              | ✅ 기능 흐름도 및 구조 설계 이미지 포함 | ⚠️ 항목은 있지만 시각화/모듈 설계 없음 | 동료가 흐름도/역할 분리까지 상세 설계함                    |
| 기능 구현     | init, makedir, create, read, list, export/import 구현 | ✅ 전체 구현                            | ✅ 전체 구현                           | 구현 자체는 동등함, 코드 구조 설계는 동료가 더 명확함      |
| 영속성        | myfs.dat 저장/복원, revive 함수, Map 변환 처리        | ✅ 파일 구조 분리(myfs.dat/dir/info)    | ✅ 단일 파일(myfs.dat) 사용            | 동료는 파일 종류 분리 설계, 나는 하나의 JSON으로 저장 처리 |
| 단위 테스트   | Jest 테스트 구성, 정상/예외 케이스 테스트 작성        | ✅ 각 기능 별 케이스, 커버리지 확인     | ✅ 대부분 구현, 일부 미흡              | 테스트 항목은 구현, 예외 처리나 삭제 기능 테스트는 미흡함  |
| 테스트 설계   | 테스트 순서 계획, 함수 우선순위, 커버리지 전략        | ✅ 계획 수립 및 커버리지 수치 목표      | ⚠️ 일부 항목만 있음                    | 테스트 계획은 동료가 더 명확히 문서화함                    |
| 입력 처리     | 명령어 파싱, 인자 개수 체크, 에러 처리 로직           | ✅ 상세 예외 처리                       | ✅ 기본적인 토큰 분리                  | 동료는 인자 수 오류/포맷 오류에 더 철저한 메시지 처리      |
| 출력 처리     | 출력 메시지 형식 통일, 성공/오류 응답                 | ✅ 정형화된 출력 설계                   | ✅ 명령어에 따른 출력 작성             | 둘 다 명령어별 응답을 잘 구성했음                          |
| 문서화        | README, 학습정리, 클래스/기능 구조도                  | ✅ 설계 이미지, 체크리스트 포함         | ⚠️ 단순 README.md만 작성성             | 동료는 구조 다이어그램까지 포함해 더 풍부한 문서화         |

## 🔍 **종합 분석**

- 구현 파트는 핵심 기능(`init`, `makedir`, `create`, `read`, `list`, `영속성`) 중심으로 잘 진행되어 있으며,
- 단위 테스트도 영속성까지 테스트한 점이 우수합니다.
- 다만, `사전 학습`과 `요구사항/설계 분석`은 README.md 등에 명확하게 기술되어야 미션의 완성도로 인정받기 좋습니다.
- 특히 `import/export`, 시스템콜/파일 포맷 등은 이후 기능 확장성 측면에서도 중요합니다.

---

# Day08

오늘 미션에서는 다른 팀원들과 비교했을 때, 학습 주제를 구체적으로 정리하지 못한 점이 아쉬웠습니다. 앞으로는 문제를 전체적으로 파악한 뒤, 내가 학습해야 할 내용을 보다 체계적이고 구체적으로 정리해두면, 학습 과정에서 방향을 잃지 않고 보다 효율적으로 학습을 이어갈 수 있을 것 같습니다.

## 📊 비교 통계표

| 항목 구분         | 주요 세부 항목                                                                         | 동료 리스트 상세도                          | 나의 리스트 상세도                      | 설명                                               |
| ----------------- | -------------------------------------------------------------------------------------- | ------------------------------------------- | --------------------------------------- | -------------------------------------------------- |
| 사전 학습         | 함수형 패러다임, 순수함수, 불변성, 참조 투명성, 고차함수(map/filter/reduce), 클로저 등 | ✅ 개념별 정의 + 활용 예시 정리 포함        | ✅ 주제 나열 + 일부 개념 정의           | 동료는 개념과 코드 적용 예시를 상세히 병기함.      |
| 함수형 데이터구조 | Immutable LinkedList/HashMap 개념, 역할, 불변성 보장 방식                              | ✅ 구조도, API 명세 포함 설계               | ✅ 클래스/메서드별 기능 정리됨          | 동료는 트리 구조와 persistent 구조까지 설계에 포함 |
| 연결 리스트 구현  | append, insert, remove, item, clear 등 메서드 구현과 테스트                            | ✅ 각 메서드 테스트, map/filter/reduce 구현 | ✅ 주요 메서드 구현 및 사용             | 동료는 고차함수 map/reduce까지 고도화 적용함.      |
| 해시맵 구현       | 해시함수, 버킷 설계, 충돌 해결(체이닝), get/set/delete, 고차함수 적용                  | ✅ 비트마스크 기반 트리형 버킷 설계 포함    | ✅ 해시 + LinkedList로 체이닝 구현      | 동료는 clojure-style 트리 구조로 확장              |
| TDD 테스트        | 각 연산별 Jest 테스트 (정상/에러 케이스)                                               | ✅ map/filter/reduce까지 테스트 포함        | ✅ 기본 메서드별 테스트 존재            | 동료는 edge case 중심 테스트 커버리지가 더 넓음.   |
| 도서 기능 구현    | add, rent, return, sortByDate, top10rent, findBy, totalRent                            | ✅ 각 함수 고차함수 적용 + 불변성 리턴 설계 | ✅ 요구 기능 함수 구현 + 불변 객체 리턴 | 동료는 map/reduce 등 고차함수 적극 활용함.         |
| 고차함수 적용     | map/filter/reduce를 데이터 흐름에 적용                                                 | ✅ 연결리스트/해시맵/도서 로직 전반 적용    | ⚠️ 기본 구조에만 제한적으로 적용        |                                                    |
| 리팩토링          | 불변성, 참조 투명성 기반으로 리팩토링                                                  | ✅ 모든 메서드가 순수 함수화됨              | ⚠️ 일부 상태 기반 처리 존재             |                                                    |
| README 및 정리    | 설계 다이어그램, 데이터 흐름, 체크리스트 포함                                          | ✅ 구조도 및 설계 철학 포함 정리            | ⚠️ 체크포인트 및 기본 흐름 요약에 그침  | 동료는 데이터 흐름/패턴/철학까지 정리              |

## 📝 총평

- 핵심 기능 구현 및 클래스 분리, 불변 객체 처리 등 함수형 프로그래밍 핵심 요소를 충실히 반영했습니다.
- 다만 `고차함수(map, filter, reduce)`의 광범위한 활용, 트리 기반 확장 구조, 선언적 데이터 흐름 등의 활용은 동료 대비 다소 부족합니다.
- ✅ 체크포인트 항목을 중심으로 보완하면 전체 함수형 스타일 완성도가 더욱 높아질 것입니다.

---

# Day09

이번 미션에서는 학습 범위를 제대로 파악하지 못해 내용을 충분히 이해하지 못했고, 결국 미션을 마무리하지 못해 아쉬움이 컸습니다. 체크리스트 통계를 통해서도 학습에 대한 이해도가 부족했음을 확인할 수 있었습니다. 이번 경험을 통해, 나에게 주어진 테스크를 수행하기 위해 어떤 사전 학습이 필요한지 명확히 파악하고, 학습한 내용을 유기적으로 연결해 나가는 태도가 중요하다는 것을 깨달았습니다.

## 📊 비교 통계표

| 항목                       | 동료 체크리스트                                                                                                                  | 사용자 체크리스트                                                                                                       | 개선 포인트                                                                                                                                   |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| **CS 기반 개념 학습 명시** | `동시성 vs 병렬성`, `Context Switch`, `Deadlock`, `Race Condition`, `IPC`, `이벤트 루프` 등 **개념을 주제별로 분리하여 구체화**  | `스케줄링 방식`, `클로저 기반 이벤트 핸들링` 등은 포함되었지만 **중요한 용어(Race Condition, Deadlock 등)의 명시 부족** | 용어 중심으로 나열해서 **CS 지식 기반을 강조**하세요. 예: `Context Switching`, `병렬성`, `Race Condition`, `Lock-Free`, `Critical Section` 등 |
| **학습 흐름 구조화**       | `what → when → how → who → where → why`로 질문 기반 설계                                                                         | 없음                                                                                                                    | **질문 기반 사고 프레임워크 적용**. 예: "Race Condition은 언제 발생하며, 왜 해결이 필요한가?"                                                 |
| **관찰 포인트 다양성**     | `BottleNeck`, `DeadLock`, `EventEmitter 내부 흐름`, `Queue 종류별 비교` 등 **깊은 관찰 항목 포함**                               | `completed 플래그`, `subscriber 해제` 등 로직 위주의 구현 관찰 중심                                                     | 단순 구현 외에도, **내부 처리 흐름과 문제 발생 지점까지 시야 확장 필요**                                                                      |
| **구현 로직 단계적 분해**  | `스레드 멈춤: setTimeout / await 조합`, `스레드 IPC: postMessage / parentPort`, `다이어그램 시각화` 등 **구체적 구현 수단 명시** | `스레드 멈춤`, `IPC`, `종료` 등은 추상적 레벨                                                                           | 각 기능마다 **실제 사용한 기술/코드/설계 패턴을 나열하면 더 명확해짐** (예: "스레드 종료: worker.terminate + worker.on('exit') 조합")         |
| **시각화 및 설계 명시**    | `다이어그램`, `Queue 시각화`, `스케줄링 흐름`, `EventEmitter 패턴 흐름도` 등 **시각화 강조**                                     | `시퀀스 다이어그램`, `Pub-Sub 흐름` 언급은 있음                                                                         | **Queue 처리 흐름, Lock 충돌 발생 위치, Context Switch 타이밍 등을 시각화 항목에 추가**하면 설계력이 강조됨                                   |
| **비동기 큐 구분**         | `SyncQueue`, `AsyncQueue`, `DelayQueue` 명확히 분리하고 비교                                                                     | 큐는 언급되어 있으나 비교 또는 구분 없음                                                                                | 큐 간 차이점(스케줄링 시점, blocking 여부 등)을 정리하면 좋음                                                                                 |

</details>
